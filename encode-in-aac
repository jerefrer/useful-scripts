#!/usr/bin/env python3
import os
import sys
import subprocess
import json
import time
from pathlib import Path
from datetime import datetime, timedelta
from rich.console import Console
from rich.progress import (
    Progress,
    SpinnerColumn,
    BarColumn,
    TextColumn,
    TimeRemainingColumn,
    TransferSpeedColumn,
)
from rich.panel import Panel
from rich.table import Table
from rich.live import Live
from rich import box
from rich.layout import Layout

class ConversionManager:
    def __init__(self, input_dir, output_dir):
        self.input_dir = Path(os.path.expanduser(input_dir)).resolve()
        self.output_dir = Path(os.path.expanduser(output_dir)).resolve()
        self.progress_file = self.output_dir / '.conversion_progress.json'
        self.conversion_state = self._load_progress()
        self.processing_speed = None
        self.files_to_process = []
        self.total_size = 0
        self.processed_size = 0
        self.console = Console()
        self.supported_extensions = {'.MP4', '.MOV'}  # Added MOV support
        
    def _load_progress(self):
        if self.progress_file.exists():
            try:
                with open(self.progress_file) as f:
                    data = json.load(f)
                    if 'processing_speed' not in data:
                        data['processing_speed'] = None
                    return data
            except json.JSONDecodeError:
                return {'completed': [], 'in_progress': None, 'processing_speed': None}
        return {'completed': [], 'in_progress': None, 'processing_speed': None}

    def _save_progress(self):
        self.conversion_state['processing_speed'] = self.processing_speed
        os.makedirs(self.output_dir, exist_ok=True)
        with open(self.progress_file, 'w') as f:
            json.dump(self.conversion_state, f)
    
    def format_time(self, seconds):
        if seconds is None:
            return "unknown"
        return str(timedelta(seconds=int(seconds)))
    
    def format_size(self, size_bytes):
        for unit in ['B', 'KB', 'MB', 'GB']:
            if size_bytes < 1024.0:
                return f"{size_bytes:.1f} {unit}"
            size_bytes /= 1024.0
        return f"{size_bytes:.1f} TB"
            
    def check_ffmpeg(self):
        try:
            subprocess.run(['ffmpeg', '-version'], capture_output=True, check=True)
            self.console.print("[bold green]✓ FFmpeg found")
            return True
        except (subprocess.SubprocessError, FileNotFoundError):
            self.console.print("[bold red]✗ Error: FFmpeg not found. Please install FFmpeg first.")
            return False
    
    def should_process_file(self, file_path):
        return not (file_path.name.startswith('._') or 
                   file_path.name.startswith('.') or 
                   '_AAC.' in file_path.name)
    
    def find_video_files(self):
        video_files = []
        for root, _, files in os.walk(self.input_dir):
            for filename in files:
                file_ext = Path(filename).suffix.upper()
                if file_ext in self.supported_extensions:
                    full_path = Path(root) / filename
                    if self.should_process_file(full_path):
                        video_files.append(full_path)
        return sorted(video_files)  # Sort files alphabetically
    
    def initialize_layout(self):
        self.table = Table.grid(padding=(0, 1))
        self.progress = Progress(
            TextColumn("[bold blue]{task.description}"),
            BarColumn(complete_style="green"),
            TextColumn("[progress.percentage]{task.percentage:>3.0f}%"),
            TextColumn("[cyan]{task.fields[speed]}"),
            TimeRemainingColumn(),
            expand=True
        )
        self.total_progress = Progress(
            TextColumn("[bold cyan]Overall"),
            BarColumn(complete_style="blue"),
            TextColumn("{task.completed}/{task.total}"),
            TimeRemainingColumn(),
            expand=True
        )
        self.table.add_row(self.progress)
        self.table.add_row(self.total_progress)
        return self.table

    def scan_and_prepare(self):
        self.files_to_process = self.find_video_files()
        self.total_size = 0
        self.processed_size = 0
        
        # Calculate sizes without sorting
        for file in self.files_to_process:
            try:
                size = file.stat().st_size
                self.total_size += size
                if str(file.relative_to(self.input_dir)) in self.conversion_state['completed']:
                    self.processed_size += size
            except Exception as e:
                self.console.print(f"[red]Error accessing {file}: {e}")
                continue
        
        summary = Table.grid(padding=(0, 2))
        summary.add_row(
            f"[cyan]Files:[/cyan] {len(self.files_to_process)}",
            f"[cyan]Total Size:[/cyan] {self.format_size(self.total_size)}",
            f"[cyan]Processed:[/cyan] {self.format_size(self.processed_size)}"
        )
        return summary

    def get_output_path(self, input_file):
        # Get the relative path from input directory
        rel_path = input_file.relative_to(self.input_dir)
        # Create the same directory structure in output directory
        output_dir = self.output_dir / rel_path.parent
        # Create output filename with _AAC suffix and original extension
        output_filename = f"{input_file.stem}_AAC{input_file.suffix}"
        return output_dir / output_filename

    def get_partial_path(self, output_path):
        return output_path.parent / f"{output_path.stem}.partial{output_path.suffix}"

    def convert_file(self, input_file, task_id):
        input_path = Path(input_file).resolve()
        rel_path = input_path.relative_to(self.input_dir)
        tracking_key = str(rel_path)
        
        output_path = self.get_output_path(input_path)
        partial_path = self.get_partial_path(output_path)
        
        file_size = input_path.stat().st_size
        
        if tracking_key in self.conversion_state['completed']:
            return True
            
        if output_path.exists():
            self.conversion_state['completed'].append(tracking_key)
            self._save_progress()
            return True
            
        # Create output directory if it doesn't exist
        os.makedirs(output_path.parent, exist_ok=True)
            
        self.conversion_state['in_progress'] = tracking_key
        self._save_progress()
        
        try:
            probe_result = subprocess.run([
                'ffprobe',
                '-v', 'quiet',
                '-print_format', 'json',
                '-show_streams',
                '-show_format',
                str(input_path)
            ], capture_output=True, text=True, check=True)
            
            probe_data = json.loads(probe_result.stdout)
            audio_streams = [s for s in probe_data['streams'] if s['codec_type'] == 'audio']
            
            ffmpeg_command = ['ffmpeg', '-i', str(input_path), '-map', '0:v:0']
            for i in range(len(audio_streams)):
                ffmpeg_command.extend(['-map', f'0:a:{i}'])
            
            ffmpeg_command.extend([
                '-c:v', 'copy',
                '-c:a', 'aac',
                '-b:a', '512k',
                '-ar', '48000',
                '-aac_coder', 'twoloop',
                '-profile:a', 'aac_low',
                '-y',
                str(partial_path)
            ])
            
            process = subprocess.Popen(
                ffmpeg_command,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                universal_newlines=True
            )
            
            start_time = time.time()
            duration = float(probe_data['format']['duration'])
            
            while True:
                output = process.stderr.readline()
                
                if output == '' and process.poll() is not None:
                    break
                    
                if output and 'time=' in output:
                    try:
                        time_str = output.split('time=')[1].split()[0]
                        current_time = sum(float(x) * 60 ** i for i, x in enumerate(reversed(time_str.split(':'))))
                        progress_value = (current_time / duration) * 100
                        current_size = partial_path.stat().st_size if partial_path.exists() else 0
                        speed = current_size / (time.time() - start_time) / 1024 / 1024
                        self.progress.update(task_id, completed=progress_value, speed=f"{speed:.1f} MB/s")
                    except:
                        pass
            
            if process.returncode == 0:
                partial_path.rename(output_path)
                self.conversion_state['completed'].append(tracking_key)
                self.conversion_state['in_progress'] = None
                self.processed_size += file_size
                self._save_progress()
                return True
            else:
                raise subprocess.CalledProcessError(process.returncode, ffmpeg_command)
            
        except Exception as e:
            if partial_path.exists():
                partial_path.unlink()
            self.conversion_state['in_progress'] = None
            self._save_progress()
            return False

    def process_directory(self):
        if not self.check_ffmpeg():
            return False

        with Live(Panel("Scanning...", title="Video Format Converter", border_style="blue"), console=self.console) as live:
            summary = self.scan_and_prepare()
            if not self.files_to_process:
                live.update(Panel("[yellow]No files to process!", title="Video Format Converter", border_style="yellow"))
                return True

            # Initialize progress displays
            layout = Table.grid(padding=(1, 0))
            layout.add_row(Panel.fit("[bold blue]Video Format Converter[/bold blue]", box=box.DOUBLE))
            layout.add_row(Panel(summary, box=box.ROUNDED))
            layout.add_row(Panel(self.initialize_layout(), box=box.ROUNDED))
            live.update(layout)

            total_task = self.total_progress.add_task("progress", total=len(self.files_to_process))
            success = True

            for file in self.files_to_process:
                file_task = self.progress.add_task(
                    str(file.name),
                    total=100,
                    speed="0 MB/s"
                )
                
                if not self.convert_file(file, file_task):
                    success = False
                
                self.progress.remove_task(file_task)
                self.total_progress.advance(total_task)

            if success:
                layout.add_row(Panel("[bold green]✓ All files processed successfully!", border_style="green"))
            else:
                layout.add_row(Panel("[bold red]✗ Some files failed to process!", border_style="red"))
            live.update(layout)

        return success

def main():
    if len(sys.argv) != 3:
        console = Console()
        console.print(Panel(
            "[bold red]Error:[/bold red] Missing input/output directories\n\n"
            f"Usage: {sys.argv[0]} <input_directory> <output_directory>",
            title="Video Format Converter",
            border_style="red"
        ))
        sys.exit(1)
        
    input_dir = sys.argv[1]
    output_dir = sys.argv[2]
    
    if not os.path.isdir(input_dir):
        console = Console()
        console.print(f"[bold red]Error:[/bold red] {input_dir} is not a directory")
        sys.exit(1)
        
    converter = ConversionManager(input_dir, output_dir)
    success = converter.process_directory()
    sys.exit(0 if success else 1)

if __name__ == '__main__':
    main()