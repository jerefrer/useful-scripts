#!/usr/bin/env python3

import xml.etree.ElementTree as ET
import argparse
import os
import re
import html

def parse_time(time_str, frame_rate=25):
    """
    Parse DFXP/TTML time format to seconds.
    Handles multiple formats including:
    - HH:MM:SS:FF (frames)
    - HH:MM:SS.ms (milliseconds)
    - Ns (seconds with optional decimal)
    """
    # Handle seconds format (e.g., "1.038s")
    if time_str.endswith('s'):
        return float(time_str[:-1])
    
    # Handle frames format (HH:MM:SS:FF)
    if ':' in time_str and len(time_str.split(':')) > 3:
        h, m, s, f = time_str.split(':')
        return int(h) * 3600 + int(m) * 60 + int(s) + int(f) / frame_rate
    
    # Handle standard time format (HH:MM:SS.ms)
    if '.' in time_str:
        main_part, ms_part = time_str.split('.')
        parts = main_part.split(':')
        if len(parts) == 3:  # HH:MM:SS.ms
            h, m, s = parts
            return int(h) * 3600 + int(m) * 60 + int(s) + float('0.' + ms_part)
        elif len(parts) == 2:  # MM:SS.ms
            m, s = parts
            return int(m) * 60 + int(s) + float('0.' + ms_part)
    else:
        parts = time_str.split(':')
        if len(parts) == 3:  # HH:MM:SS
            h, m, s = parts
            return int(h) * 3600 + int(m) * 60 + int(s)
        elif len(parts) == 2:  # MM:SS
            m, s = parts
            return int(m) * 60 + int(s)
    
    # Default fallback
    print(f"Warning: Couldn't parse time format: {time_str}")
    return 0

def format_srt_time(seconds):
    """Format seconds to SRT time format: HH:MM:SS,mmm"""
    hours = int(seconds // 3600)
    minutes = int((seconds % 3600) // 60)
    seconds_remainder = seconds % 60
    milliseconds = int((seconds_remainder % 1) * 1000)
    
    return f"{hours:02d}:{minutes:02d}:{int(seconds_remainder):02d},{milliseconds:03d}"

def extract_text_from_p_element(p_elem):
    """Extract text content from a p element, handling <br/> tags."""
    # Convert br tags to newlines
    text = ""
    if p_elem.text:
        text += p_elem.text
    
    for child in p_elem:
        if child.tag.endswith('br'):
            text += '\n'
        if child.tail:
            text += child.tail
    
    # Handle the case where <br> is represented as a complete element with namespace
    br_pattern = re.compile(r'<br\s*/>')
    full_xml = ET.tostring(p_elem, encoding='unicode')
    full_xml = br_pattern.sub('\n', full_xml)
    
    # Extract text content from the modified XML
    # This is a fallback if the previous method didn't work well
    if '<br' in full_xml:
        text_parts = []
        for line in full_xml.split('<br'):
            clean_line = re.sub(r'<[^>]+>', '', line)
            clean_line = clean_line.strip()
            if clean_line:
                text_parts.append(clean_line)
        text = '\n'.join(text_parts)
    
    # If still no success, try to extract all text
    if not text.strip() and p_elem.text:
        text = p_elem.text
        
    # Handle HTML entities
    text = html.unescape(text)
    
    # Clean up the text
    text = re.sub(r'\s+', ' ', text)
    text = text.strip()
    
    return text

def convert_dfxp_to_srt(dfxp_file, srt_file, frame_rate=25):
    """Convert a DFXP file to SRT format."""
    try:
        tree = ET.parse(dfxp_file)
        root = tree.getroot()
        
        # Define namespaces
        namespaces = {
            'tt': 'http://www.w3.org/ns/ttml',
            'tts': 'http://www.w3.org/ns/ttml#styling',
            'ttp': 'http://www.w3.org/ns/ttml#parameter'
        }
        
        # Find all p elements - try different approaches
        p_elems = []
        
        # Try with namespaces first
        try:
            p_elems = root.findall('.//tt:div/tt:p', namespaces)
        except:
            pass
            
        # If no elements found, try without namespaces
        if not p_elems:
            try:
                p_elems = root.findall('.//div/p')
            except:
                pass
        
        # If still no elements, try broader approaches
        if not p_elems:
            try:
                p_elems = root.findall('.//tt:p', namespaces)
            except:
                pass
                
        if not p_elems:
            try:
                p_elems = root.findall('.//p')
            except:
                pass
        
        if not p_elems:
            print(f"No subtitle elements found in {dfxp_file}")
            return False
            
        print(f"Found {len(p_elems)} subtitle elements in {dfxp_file}")
        
        # Extract and sort subtitle entries
        subtitle_entries = []
        for elem in p_elems:
            begin = elem.get('begin')
            end = elem.get('end')
            
            if begin is not None:
                begin_seconds = parse_time(begin, frame_rate)
                end_seconds = parse_time(end, frame_rate) if end is not None else begin_seconds + 5
                
                # Extract text, handling BR tags
                text = extract_text_from_p_element(elem)
                
                if text:
                    subtitle_entries.append({
                        'begin': begin_seconds,
                        'end': end_seconds,
                        'text': text
                    })
        
        # Sort by begin time
        subtitle_entries.sort(key=lambda x: x['begin'])
        
        # Write SRT file
        with open(srt_file, 'w', encoding='utf-8') as f:
            for i, entry in enumerate(subtitle_entries, 1):
                f.write(f"{i}\n")
                f.write(f"{format_srt_time(entry['begin'])} --> {format_srt_time(entry['end'])}\n")
                f.write(f"{entry['text']}\n\n")
        
        print(f"Successfully converted {len(subtitle_entries)} subtitles to {srt_file}")
        return True
    
    except Exception as e:
        print(f"Error converting {dfxp_file} to SRT: {e}")
        return False

def main():
    parser = argparse.ArgumentParser(description='Convert DFXP subtitle files to SRT format')
    parser.add_argument('--input', '-i', required=True, help='Input DFXP file')
    parser.add_argument('--output', '-o', help='Output SRT file (default: same name with .srt extension)')
    parser.add_argument('--framerate', '-r', type=float, default=25, help='Frame rate for frame-based timing (default: 25)')
    
    args = parser.parse_args()
    
    input_file = args.input
    if not os.path.exists(input_file):
        print(f"Error: Input file not found: {input_file}")
        return
    
    output_file = args.output
    if not output_file:
        output_file = os.path.splitext(input_file)[0] + '.srt'
    
    print(f"Converting {input_file} to {output_file}...")
    print(f"Using frame rate: {args.framerate} fps")
    
    success = convert_dfxp_to_srt(input_file, output_file, args.framerate)
    
    if success:
        print(f"Conversion completed successfully.")
    else:
        print("Conversion failed.")

if __name__ == "__main__":
    main()