#!/bin/bash
#
# Keep a mounted external drive awake by periodically reading a small file.
# Usage: ./keep_drive_awake.sh /Volumes/MyDrive
#

set -euo pipefail

if [[ $# -lt 1 ]]; then
  echo "Usage: $0 /Volumes/YourDrive [interval_seconds] [read|write]"
  exit 1
fi

VOLUME_PATH="$1"
TIMEOUT="${2:-15}"
MODE=$(printf '%s' "${3:-write}" | tr '[:upper:]' '[:lower:]')

if [[ ! -d "$VOLUME_PATH" ]]; then
  echo "‚ùå Error: '$VOLUME_PATH' does not exist or is not a directory."
  exit 1
fi

case "$MODE" in
  read|write)
    ;;
  *)
    echo "‚ùå Error: mode must be 'read' or 'write'."
    exit 1
    ;;
esac

echo "üåÄ Keeping drive awake at: $VOLUME_PATH (interval: ${TIMEOUT}s, mode: $MODE)"

# Ensure a dedicated keepalive file exists so we can safely write to it
KEEPALIVE_FILE="$VOLUME_PATH/.keepalive"
KEEPALIVE_CREATED=0
if [[ ! -f "$KEEPALIVE_FILE" ]]; then
  echo "Creating keepalive file at $KEEPALIVE_FILE"
  dd if=/dev/zero of="$KEEPALIVE_FILE" bs=1K count=1 status=none conv=notrunc
  KEEPALIVE_CREATED=1
fi

cleanup() {
  if [[ $KEEPALIVE_CREATED -eq 1 && -f "$KEEPALIVE_FILE" ]]; then
    rm -f "$KEEPALIVE_FILE"
    echo
    echo "üßπ Removed keepalive file $KEEPALIVE_FILE"
  fi
}

trap cleanup EXIT INT TERM

# Loop forever until user interrupts (Ctrl+C)
while true; do
  if mount | grep -q "$VOLUME_PATH"; then
    case "$MODE" in
      read)
        dd if="$KEEPALIVE_FILE" of=/dev/null bs=1M count=1 status=none
        ;;
      write)
        # Overwrite a few bytes to force an actual disk write and avoid cache hits
        dd if=/dev/urandom of="$KEEPALIVE_FILE" bs=4 count=1 conv=notrunc oflag=sync status=none
        ;;
    esac
    printf "."
    # echo "Pinged drive at $(date '+%H:%M:%S')"
  else
    echo "‚ö†Ô∏è  Volume $VOLUME_PATH no longer mounted. Exiting."
    exit 0
  fi
  sleep "$TIMEOUT"
done
