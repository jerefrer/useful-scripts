#!/bin/bash
# smart-ytradio.sh - Intelligently finds the best audio format

URL="$1"

# Suppress all output except for clean UI

# Get stream title and remove date/time
TITLE=$(yt-dlp --get-title "$URL" 2>/dev/null)
[ -z "$TITLE" ] && TITLE="YouTube Audio"
# Remove trailing date/time (format: YYYY-MM-DD HH:MM or similar)
TITLE=$(echo "$TITLE" | sed -E 's/[[:space:]]+[0-9]{4}-[0-9]{2}-[0-9]{2}[[:space:]][0-9]{2}:[0-9]{2}$//')

# Get format info and extract audio-only options
FORMATS_INFO=$(yt-dlp -F "$URL" 2>/dev/null)
AUDIO_ONLY_FORMATS_RAW=$(echo "$FORMATS_INFO" | grep -E "audio only.*unknown|Audio only" | awk '{print $1}' | head -3)
if [ -n "$AUDIO_ONLY_FORMATS_RAW" ]; then
    AUDIO_ONLY_FORMATS=$(echo "$AUDIO_ONLY_FORMATS_RAW" | paste -sd "/")
else
    AUDIO_ONLY_FORMATS=""
fi
LOW_RES_FORMATS_RAW=$(echo "$FORMATS_INFO" | grep -E "256x144|426x240" | head -2 | awk '{print $1}')
if [ -n "$LOW_RES_FORMATS_RAW" ]; then
    LOW_RES_FORMATS=$(echo "$LOW_RES_FORMATS_RAW" | paste -sd "/")
else
    LOW_RES_FORMATS=""
fi

if [ -n "$AUDIO_ONLY_FORMATS" ]; then
    FORMAT_STRING="$AUDIO_ONLY_FORMATS"
elif [ -n "$LOW_RES_FORMATS" ]; then
    FORMAT_STRING="$LOW_RES_FORMATS"
else
    FORMAT_STRING="bestaudio/worst"
fi

# Show a loading UI immediately
show_ui() {
    local message="$1"
    local ascii="\033[1;35m
      ‚ô™
     ‚ô´ ‚ô©
      ‚ô™
\033[0m"
    clear
    echo -e "$ascii"
    echo -e "\033[1;36m$message\033[0m\n"
}

# Animated loading UI
loading_spinner() {
    local msg="$1"
    local ascii="\033[1;35m\n      ‚ô™\n    ‚ô´   ‚ô©\n      ‚ô™\n\033[0m"
    local spin='‚†ã‚†ô‚†π‚†∏‚†º‚†¥‚†¶‚†ß‚†á‚†è'
    local i=0
    tput civis
    while [ ! -f /tmp/ytaudio_stream_ready ]; do
        i=$(( (i+1) % 10 ))
        clear
        echo -e "$ascii"
        echo -e "\033[1;36m$msg\033[0m\n"
        echo -e "\n        ${spin:$i:1}"
        sleep 0.1
    done
    tput cnorm
    rm -f /tmp/ytaudio_stream_ready
}

# Start yt-dlp in background
rm -f /tmp/ytaudio_stream_ready
STREAM_URL=""
( STREAM_URL=$(yt-dlp -f "$FORMAT_STRING" --get-url "$URL" 2>/dev/null); echo "$STREAM_URL" > /tmp/ytaudio_stream_url; touch /tmp/ytaudio_stream_ready ) &
loading_spinner "Loading stream info..."
# Do not clear here; let spinner handle UI
echo -ne "" # placeholder, do nothing
STREAM_URL=$(cat /tmp/ytaudio_stream_url 2>/dev/null)

if [ -n "$STREAM_URL" ]; then
    spinner() {
        local pid=$1
        local spin='‚†ã‚†ô‚†π‚†∏‚†º‚†¥‚†¶‚†ß‚†á‚†è'
        local i=0
        local ascii="\033[1;35m
      ‚ô™
    ‚ô´   ‚ô©
      ‚ô™
\033[0m"
        local paused=0
        tput civis # Hide cursor
        # Set terminal to raw mode for key reading
        stty -echo -icanon time 0 min 0
        trap 'stty sane; tput cnorm; clear; exit' INT TERM
        while kill -0 $pid 2>/dev/null; do
            i=$(( (i+1) % 10 ))
            # Check for keypress (non-blocking, macOS/BSD compatible)
            key=""
            read -rsn1 -t 1 key
            if [[ $key == "p" || $key == "P" ]]; then
                if (( paused == 0 )); then
                    kill -STOP $pid
                    paused=1
                else
                    kill -CONT $pid
                    paused=0
                fi
            fi
            clear
            echo -e "$ascii"
            if (( paused == 1 )); then
                echo -e "\033[1;33m‚è∏Ô∏è  Paused\033[0m\n"
            else
                echo -e "\033[1;36müéµ Now Playing\033[0m\n"
            fi
            echo -e "   \033[1;33m$TITLE\033[0m"
            echo -e "\n        ${spin:$i:1}  Press P to pause | Press Ctrl+C to stop."
            sleep 0.1
        done
        stty sane
        tput cnorm # Show cursor
        clear
        echo -e "$ascii"
        echo -e "\033[1;32m‚úî Done playing:\033[0m\n   \033[1;33m$TITLE\033[0m\n"
    }
    # Start player in background, suppress all output
    (mpv --really-quiet --no-video --cache=yes --title="$TITLE" "$STREAM_URL" &>/dev/null) &
    MPV_PID=$!
    spinner $MPV_PID
else
    show_ui "\033[1;31m‚ùå Failed to get stream\033[0m"
    exit 1
fi