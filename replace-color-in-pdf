#!/bin/bash

# Debug mode
DEBUG=false
if [ "$1" = "--debug" ] || [ "$1" = "-d" ]; then
    DEBUG=true
    shift
fi

# Function to display usage information
usage() {
    echo "Usage: $0 [--debug] <input_pdf> [output_pdf] [from_color] [to_color]"
    echo ""
    echo "Options:"
    echo "  --debug, -d : Show debug information during processing"
    echo ""
    echo "Arguments:"
    echo "  input_pdf   : Input PDF file (required)"
    echo "  output_pdf  : Output PDF file (optional, defaults to input with ' - Red' suffix)"
    echo "  from_color  : Color to replace - RGB format (0,0,0) or hex (#000000)"
    echo "                (optional, defaults to black with tolerance for near-black)"
    echo "  to_color    : Replacement color - RGB or hex format (optional, default: #d12129)"
    echo ""
    echo "Examples:"
    echo "  $0 input.pdf"
    echo "    → Replaces black (with tolerance) with red, saves as 'input - Red.pdf'"
    echo ""
    echo "  $0 input.pdf #221f20"
    echo "    → Replaces #221f20 with red, saves as 'input - Red.pdf'"
    echo ""
    echo "  $0 input.pdf #221f20 #00ff00"
    echo "    → Replaces #221f20 with green, saves as 'input - Red.pdf'"
    echo ""
    echo "  $0 input.pdf output.pdf"
    echo "    → Replaces black with red, saves as 'output.pdf'"
    echo ""
    echo "  $0 input.pdf output.pdf #221f20"
    echo "    → Replaces #221f20 with red, saves as 'output.pdf'"
    echo ""
    echo "  $0 input.pdf output.pdf #221f20 #00ff00"
    echo "    → Replaces #221f20 with green, saves as 'output.pdf'"
    echo ""
    echo "  $0 input.pdf 0.5,0.5,0.5 1,0,0"
    echo "    → Replaces gray with red using RGB format"
    exit 1
}

# Function to convert hex color to PDF RGB format (0-1 range)
hex_to_pdf_rgb() {
    local hex=$1
    # Remove # if present
    hex=${hex#\#}

    # Validate hex format
    if [[ ! $hex =~ ^[0-9A-Fa-f]{6}$ ]]; then
        echo "Error: Invalid hex color format: #$hex" >&2
        exit 1
    fi

    # Extract RGB components (hex to decimal)
    local r=$((16#${hex:0:2}))
    local g=$((16#${hex:2:2}))
    local b=$((16#${hex:4:2}))

    # Convert to PDF format (0-1 range)
    # Using awk for more portable floating point math
    echo "$r $g $b" | awk '{printf "%.2f %.2f %.2f", $1/255, $2/255, $3/255}'
}

# Function to convert color (RGB or hex) to PDF format
convert_color() {
    local color=$1

    if [[ $color =~ ^#[0-9A-Fa-f]{6}$ ]]; then
        # Hex format
        hex_to_pdf_rgb "$color"
    else
        # RGB format - replace commas with spaces
        echo "$color" | sed 's/,/ /g'
    fi
}

# Check for help flag
if [ "$1" = "-h" ] || [ "$1" = "--help" ]; then
    usage
fi

# Check if input file is provided
if [ -z "$1" ]; then
    echo "Error: Input file is required."
    usage
fi

input_file="$1"

# Check if input file exists
if [ ! -f "$input_file" ]; then
    echo "Error: Input file '$input_file' does not exist."
    exit 1
fi

# Function to check if argument looks like a color
is_color() {
    local arg="$1"
    # Check if it starts with # (hex) or contains comma (RGB format)
    [[ "$arg" =~ ^# ]] || [[ "$arg" =~ , ]] || [[ "$arg" =~ ^[0-9.]+$ ]]
}

# Smart argument parsing
use_tolerance=true
from_color=""
to_color="#d12129"  # Default red
output_file=""

# Check second argument
if [ -n "$2" ]; then
    if is_color "$2"; then
        # Second arg is from_color
        from_color="$2"
        use_tolerance=false

        # Third arg (if present) is to_color
        if [ -n "$3" ]; then
            to_color="$3"
        fi
    else
        # Second arg is output_file
        output_file="$2"

        # Third arg (if present) is from_color
        if [ -n "$3" ]; then
            from_color="$3"
            use_tolerance=false
        fi

        # Fourth arg (if present) is to_color
        if [ -n "$4" ]; then
            to_color="$4"
        fi
    fi
fi

# Generate output filename if not provided
if [ -z "$output_file" ]; then
    # Extract directory, filename, and extension
    dir=$(dirname "$input_file")
    base=$(basename "$input_file")
    filename="${base%.*}"
    extension="${base##*.}"

    # Handle case where dir is "."
    if [ "$dir" = "." ]; then
        output_file="${filename} - Red.${extension}"
    else
        output_file="${dir}/${filename} - Red.${extension}"
    fi
fi

# Convert to_color to PDF format
to_color_pdf=$(convert_color "$to_color")

# Create a temporary file
temp_file=$(mktemp)

# Uncompress PDF
if [ "$DEBUG" = true ]; then
    echo "Debug: Uncompressing PDF..."
fi
pdftk "$input_file" output "$temp_file" uncompress

# Count color operators before replacement (for debug)
if [ "$DEBUG" = true ]; then
    rgb_count=$(grep -oE '[0-9.]+ [0-9.]+ [0-9.]+ (rg|RG)' "$temp_file" | wc -l)
    cmyk_count=$(grep -oE '[0-9.]+ [0-9.]+ [0-9.]+ [0-9.]+ (k|K)' "$temp_file" | wc -l)
    gray_count=$(grep -oE '[0-9.]+ (g|G)' "$temp_file" | wc -l)
    scn_count=$(grep -oE '[0-9.]+\s+[0-9.]+\s+[0-9.]+\s+[0-9.]+\s+(scn|SCN)' "$temp_file" | wc -l)
    echo "Debug: Found $rgb_count RGB color operators (rg/RG)"
    echo "Debug: Found $cmyk_count CMYK color operators (k/K)"
    echo "Debug: Found $gray_count Grayscale color operators (g/G)"
    echo "Debug: Found $scn_count SetColor operators (scn/SCN)"
    echo "Debug: Analyzing color samples..."
    echo "Debug: RGB samples:"
    grep -oE '[0-9.]+ [0-9.]+ [0-9.]+ (rg|RG)' "$temp_file" | head -5
    echo "Debug: CMYK samples:"
    grep -oE '[0-9.]+ [0-9.]+ [0-9.]+ [0-9.]+ (k|K)' "$temp_file" | head -5
    echo "Debug: Grayscale samples:"
    grep -oE '[0-9.]+ (g|G)' "$temp_file" | head -5
    echo "Debug: SetColor (CMYK) samples:"
    grep -oE '[0-9.]+\s+[0-9.]+\s+[0-9.]+\s+[0-9.]+\s+(scn|SCN)' "$temp_file" | head -5
fi

if [ "$use_tolerance" = true ]; then
    # Replace black and near-black colors (tolerance mode)
    # Matches colors where all RGB values are <= 0.15 (approximately #262626)
    # This includes pure black (0,0,0) and dark colors like #221f20

    if [ "$DEBUG" = true ]; then
        echo "Debug: Tolerance mode - replacing dark colors (R,G,B <= 0.15)"
        echo "Debug: Target color: $to_color_pdf"
    fi

    # RGB tolerance replacement
    perl -i -pe '
        s{
            (\b0?\.?\d{1,2}(?:\.\d+)?\b)  # First number (R)
            (\s+)
            (\b0?\.?\d{1,2}(?:\.\d+)?\b)  # Second number (G)
            (\s+)
            (\b0?\.?\d{1,2}(?:\.\d+)?\b)  # Third number (B)
            (\s+)
            (rg|RG)\b                      # Operator
        }{
            my ($r, $s1, $g, $s2, $b, $s3, $op) = ($1, $2, $3, $4, $5, $6, $7);
            # Check if all components are <= 0.15 (dark/black)
            if ($r <= 0.15 && $g <= 0.15 && $b <= 0.15) {
                "'"$to_color_pdf"'$s3$op"
            } else {
                "$r$s1$g$s2$b$s3$op"
            }
        }xge
    ' "$temp_file"

    # CMYK tolerance replacement (black in CMYK is 0 0 0 1, dark colors have high K value)
    perl -i -pe '
        s{
            (\b0?\.?\d{1,2}(?:\.\d+)?\b)  # C
            (\s+)
            (\b0?\.?\d{1,2}(?:\.\d+)?\b)  # M
            (\s+)
            (\b0?\.?\d{1,2}(?:\.\d+)?\b)  # Y
            (\s+)
            (\b0?\.?\d{1,2}(?:\.\d+)?\b)  # K
            (\s+)
            (k|K)\b                        # Operator
        }{
            my ($c, $s1, $m, $s2, $y, $s3, $k, $s4, $op) = ($1, $2, $3, $4, $5, $6, $7, $8, $9);
            # Check if K >= 0.85 (dark/black in CMYK)
            if ($k >= 0.85 && $c <= 0.15 && $m <= 0.15 && $y <= 0.15) {
                "'"$to_color_pdf"'$s4$op"
            } else {
                "$c$s1$m$s2$y$s3$k$s4$op"
            }
        }xge
    ' "$temp_file"

    # Grayscale tolerance replacement (0 is black, values <= 0.15 are dark)
    perl -i -pe '
        s/(\d+(?:\.\d+)?)\s+(g|G)\b/do{
            my ($gray, $op) = ($1, $2);
            if ($gray <= 0.15) {
                "'"$to_color_pdf"' rg";
            } else {
                "$gray $op";
            }
        }/ge
    ' "$temp_file"

    # SetColor (scn/SCN) tolerance replacement - handles CMYK format
    # Also need to change the color space from /CS0 cs to /DeviceRGB cs for rg to work
    perl -i -pe '
        # First replace the color space definitions for black colors
        s{(/CS\d+)\s+(cs|CS)\s+(\d+(?:\.\d+)?)\s+(\d+(?:\.\d+)?)\s+(\d+(?:\.\d+)?)\s+(\d+(?:\.\d+)?)\s+(scn|SCN)\b}{
            my ($csname, $csop, $c, $m, $y, $k, $op) = ($1, $2, $3, $4, $5, $6, $7);
            # Check if it is dark (high K value and low CMY)
            if ($k >= 0.85 && $c <= 0.15 && $m <= 0.15 && $y <= 0.15) {
                "/DeviceRGB $csop '"$to_color_pdf"' rg";
            } else {
                "$csname $csop $c $m $y $k $op";
            }
        }ge
    ' "$temp_file"
else
    # Exact color replacement mode
    from_color_pdf=$(convert_color "$from_color")

    if [ "$DEBUG" = true ]; then
        echo "Debug: Exact mode - replacing $from_color_pdf"
        echo "Debug: Target color: $to_color_pdf"
    fi

    # Replace exact RGB color matches
    perl -i -pe 's/\Q'"$from_color_pdf"'\E rg/'"$to_color_pdf"' rg/g' "$temp_file"
    perl -i -pe 's/\Q'"$from_color_pdf"'\E RG/'"$to_color_pdf"' RG/g' "$temp_file"

    # Replace grayscale if it matches (convert single value to RGB equivalent)
    # Extract first component of from_color to check if it's grayscale
    gray_value=$(echo "$from_color_pdf" | awk '{print $1}')
    perl -i -pe 's/\b'"$gray_value"' (g|G)\b/'"$to_color_pdf"' rg/g' "$temp_file"
fi

# Count replacements (for debug)
if [ "$DEBUG" = true ]; then
    rgb_after=$(grep -oE '[0-9.]+ [0-9.]+ [0-9.]+ (rg|RG)' "$temp_file" | wc -l)
    gray_after=$(grep -oE '[0-9.]+ (g|G)' "$temp_file" | wc -l)
    scn_after=$(grep -oE '[0-9.]+\s+[0-9.]+\s+[0-9.]+\s+[0-9.]+\s+(scn|SCN)' "$temp_file" | wc -l)
    new_color_count=$(grep -F "$to_color_pdf" "$temp_file" | wc -l)
    echo "Debug: RGB operators after: $rgb_after (was $rgb_count)"
    echo "Debug: Grayscale operators after: $gray_after (was $gray_count)"
    echo "Debug: SetColor operators after: $scn_after (was $scn_count)"
    echo "Debug: New color occurrences: $new_color_count"
fi

# Compress and save output
if [ "$DEBUG" = true ]; then
    echo "Debug: Compressing and saving to $output_file..."
fi
pdftk "$temp_file" output "$output_file" compress

# Clean up
rm "$temp_file"

echo "Conversion complete. Output saved as '$output_file'"
