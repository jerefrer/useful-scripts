#!/usr/bin/env python3
"""Align PDF pages by centering detected content - preserves original quality."""

import sys
import os
import cv2
import numpy as np
import fitz  # PyMuPDF


def find_content_rect(pix, dpi, margin_percent=2):
    """Detect main content block bounding box from pixmap."""
    # Convert pixmap to numpy array
    img = np.frombuffer(pix.samples, dtype=np.uint8).reshape(pix.height, pix.width, pix.n)
    if pix.n == 4:  # RGBA
        gray = cv2.cvtColor(img, cv2.COLOR_RGBA2GRAY)
    else:  # RGB
        gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)

    h, w = gray.shape

    # Margin to ignore scanner/edge artifacts
    margin_x = int(w * margin_percent / 100)
    margin_y = int(h * margin_percent / 100)

    # Threshold to find non-white content
    _, binary = cv2.threshold(gray, 230, 255, cv2.THRESH_BINARY_INV)

    # Mask out margins
    binary[:margin_y, :] = 0
    binary[-margin_y:, :] = 0
    binary[:, :margin_x] = 0
    binary[:, -margin_x:] = 0

    # Aggressive morphological closing to merge text into blocks
    # Scale kernel size with DPI (base: 50px at 600 DPI = ~6 points)
    kernel_size = max(10, int(50 * dpi / 600))
    kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (kernel_size, kernel_size))
    binary = cv2.morphologyEx(binary, cv2.MORPH_CLOSE, kernel)

    # Find connected components and use the largest one (main text block)
    num_labels, labels, stats, centroids = cv2.connectedComponentsWithStats(binary)

    if num_labels <= 1:
        return None

    # Skip background (label 0), find largest component
    largest_label = 1 + np.argmax(stats[1:, cv2.CC_STAT_AREA])
    x = stats[largest_label, cv2.CC_STAT_LEFT]
    y = stats[largest_label, cv2.CC_STAT_TOP]
    bw = stats[largest_label, cv2.CC_STAT_WIDTH]
    bh = stats[largest_label, cv2.CC_STAT_HEIGHT]

    return (x, y, bw, bh)


def align_pecha_pages(input_pdf, output_pdf):
    doc = fitz.open(input_pdf)

    # Render at 300 DPI for detection
    dpi = 300
    zoom = dpi / 72  # 72 is default PDF DPI
    mat = fitz.Matrix(zoom, zoom)

    shifts = []
    for i, page in enumerate(doc):
        print(f"  Analyzing page {i + 1}/{len(doc)}... ", end="")

        pix = page.get_pixmap(matrix=mat)
        rect = find_content_rect(pix, dpi)

        if rect:
            x, y, w, h = rect
            # Content center in pixels (at 150 DPI)
            content_cx = x + w / 2
            content_cy = y + h / 2
            # Page center in pixels
            page_cx = pix.width / 2
            page_cy = pix.height / 2
            # Shift needed in pixels at 150 DPI
            shift_x_px = page_cx - content_cx
            shift_y_px = page_cy - content_cy
            # Convert to PDF points (72 DPI)
            shift_x = shift_x_px / zoom
            shift_y = shift_y_px / zoom
            print(f"shift ({shift_x:+.1f}, {shift_y:+.1f}) pts")
            shifts.append((shift_x, shift_y))
        else:
            print("no content detected")
            shifts.append((0, 0))

    # Create new PDF with shifted content
    new_doc = fitz.open()

    for i, page in enumerate(doc):
        shift_x, shift_y = shifts[i]

        # Create new page with same dimensions
        new_page = new_doc.new_page(width=page.rect.width, height=page.rect.height)

        # Target rect shifted by our offset
        # PyMuPDF uses top-left origin with y increasing downward (like images)
        target = fitz.Rect(
            shift_x,
            shift_y,
            page.rect.width + shift_x,
            page.rect.height + shift_y
        )

        # Insert original page at shifted position
        new_page.show_pdf_page(target, doc, i)

    new_doc.save(output_pdf, garbage=4, deflate=True)
    new_doc.close()
    doc.close()


def main():
    if len(sys.argv) < 2:
        print(f"Usage: {os.path.basename(sys.argv[0])} <input.pdf> [output.pdf]")
        sys.exit(1)

    input_pdf = sys.argv[1]

    if not os.path.exists(input_pdf):
        print(f"Error: File not found: {input_pdf}")
        sys.exit(1)

    if len(sys.argv) >= 3:
        output_pdf = sys.argv[2]
    else:
        base, ext = os.path.splitext(input_pdf)
        output_pdf = f"{base}_aligned{ext}"

    print(f"Aligning pages: {input_pdf} â†’ {output_pdf}")
    align_pecha_pages(input_pdf, output_pdf)
    print(f"Done: {output_pdf}")


if __name__ == "__main__":
    main()
